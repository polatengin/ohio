# Linux driver that generates a random strong password

This is a simple example of a Linux driver that generates a random strong password. The password is generated by the driver itself and can be read from `/dev/spg` (_Strong Password Generator_). The driver demonstrates how to generate random numbers, allocate device numbers, and implement file operations for a character device.

Header files used:

```c
// SPDX-License-Identifier: GPL-2.0
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/random.h>
#include <linux/cdev.h>
```

`SPDX-License-Identifier: GPL-2.0`: This is a special SPDX tag used in kernel code to specify the license under which the code is distributed.

`#include <linux/init.h>`: Contains macros for module initialization and cleanup.
`#include <linux/module.h>`: Provides macros and functions for managing kernel modules.
`#include <linux/fs.h>`: Defines structures and functions related to the Linux file system.
`#include <linux/uaccess.h>`: Provides functions for copying data between user space and kernel space.
`#include <linux/random.h>`: Includes functions for generating random numbers.
`#include <linux/cdev.h>`: Defines structures and functions for character device registration and operations.

The driver generates a random password of length 16 characters by default.

```c
static int password_len = 16;
```

The password is generated using the `generate_password()` function.

```c
static void generate_password(void)
{
  const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
  int i;

  for (i = 0; i < password_len; ++i)
  {
    password[i] = charset[get_random_int() % (sizeof(charset) - 1)];
  }
  password[password_len] = '\0';
}
```

Each time the device opened, a new password is generated.

```c
// File operations for /dev/spg
static int spg_open(struct inode *inode, struct file *file)
{
  generate_password();
  return 0;
}
```

When the device is read, the generated password is returned to the user `spg_read()`

When the device initialized, major number allocated statically and minor number allocated dynamically.

```c
static int __init spg_init(void)
{
  int ret;

  // Allocate the device number
  spg_dev_number = MKDEV(42, 0); // Major number 42, minor number 0
}
```

When the driver is removed, the device is unregistered and the allocated memory is freed.

```c
static void __exit spg_exit(void)
{
  cdev_del(&cdev);

  unregister_chrdev_region(spg_dev_number, 1);
  printk(KERN_INFO "Unregistered device: /dev/%s\n", DEVICE_NAME);
}
```

`Makefile` has targets to build the driver and clean the build artifacts.

```makefile
obj-m += spg.o

KERNELDIR ?= /lib/modules/$(shell uname -r)/build

all:
  $(MAKE) -C $(KERNELDIR) M=$(PWD) modules

clean:
  $(MAKE) -C $(KERNELDIR) M=$(PWD) clean
```

To build the driver, run `make` in the directory containing the driver source code.

```bash
make
```

To load the driver, use the `insmod` command.

```bash
sudo insmod spg.ko
```

To check if the driver is loaded, use the `lsmod` command.

```bash
lsmod | grep spg
```

To create the device file, use the `mknod` command.

```bash
sudo mknod /dev/spg c 42 0
```

To read the password generated by the driver, use the `cat` command.

```bash
cat /dev/spg
```

To unload the driver, use the `rmmod` command.

```bash
sudo rmmod spg
```

To clean the build artifacts, run `make clean`.

```bash
make clean
```

## Linux driver learnings

- Linux drivers are kernel modules that extend the functionality of the Linux kernel.
- Character device drivers interact with user space through character devices.
- Device numbers are used to identify devices in the system.
- File operations are implemented to handle `read`, `write`, `open`, and `close` operations on devices.

There are two very similar looking and working random generator drivers, `/dev/random` and `/dev/urandom`.

The difference between the two is that `/dev/random` blocks when the entropy pool is empty, while `/dev/urandom` does not block and reuses the internal state to generate random numbers.

_Entropy pool_ is a pool of random numbers that is used to generate random numbers. It is filled by various sources of randomness, such as mouse movements, keyboard inputs, network packages, etc.

> More details about the `random` and `urandom` can be found in the [random(4) - Linux manual page](https://www.man7.org/linux/man-pages/man4/urandom.4.html).
>
> Source code of the `random` generator can be found in the [drivers/char/random.c](https://elixir.bootlin.com/linux/latest/source/drivers/char/random.c) file.

On Linux systems, the `/dev/random` and `/dev/urandom` devices are just special file descriptors that can be accessed like any other file.

These devices are character devices that provide access to the kernel's random number generator.

If we list the devices in the `/dev` directory, we can see the `random` and `urandom` devices.

```bash
ls -lah /dev/
```

We can read from these devices to get random numbers.

```bash
cat /dev/random

cat /dev/urandom
```

It's better to use `head` and `hexdump` commands to read random numbers from these devices.

```bash
head -c 16 /dev/random | hexdump -c
```

Some Linux distributions may not have the `/dev/random` and `/dev/urandom` devices. In that case, we can create them using the `mknod` command.

```bash
sudo mknod /dev/random c 1 8
sudo mknod /dev/urandom c 1 9
```

The `mknod` command creates a special file with the specified major and minor numbers.

The major number `1` is used for character devices, and the minor numbers `8` and `9` are used for the `random` and `urandom` devices, respectively.

The `c` option specifies that the file is a character device.

In some scenarios we may have to create `random` and `urandom` devices with a specific names, for example, `/dev/myrandom` and `/dev/myurandom`.

```bash
sudo mknod /dev/myrandom c 1 8
sudo mknod /dev/myurandom c 1 9
```

The `myrandom` and `myurandom` devices can be used to generate random numbers.

```bash
cat /dev/myrandom
```
